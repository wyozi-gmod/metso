local a={}local function b(c,d)a[c]=d end;local function e(c)return a[c]()end;b("connection.lua",function()local f={}f.__index=f;function f:_escapeString(g)return sql.SQLStr(g)end;function f:_parseQuery(sql,h)local i=1;return sql:gsub("%?",function()local j=h[i]i=i+1;if type(j)=="string"then return self:_escapeString(j)elseif type(j)=="number"then return tostring(j)elseif j==nil then return"NULL"else error("unknown type given to sql query: "..type(j))end end)end;function f:query(sql,h)assert(type(sql)=="string","query sql must be a string")h=h or{}assert(type(h)=="table","query params must be a table")local k=self:_parseQuery(sql,h)return self._backend:query(k)end;function f:queryRow(sql,h)return self:query(sql,h):next(function(l)return l[1]end)end;function f:queryValue(sql,h)return self:queryRow(sql,h):next(function(m)if not m then return nil end;local n=next(m)if n then return m[n]end end)end;function f:insert(sql,h)return self:query(sql,h):next(function()return self._backend:queryLastInsertedId()end)end;function f.new(o)assert(not not o,"backend required")return setmetatable({_backend=o},f)end;return f end)b("toml.lua",function()local p={version=0.31,strict=true}p.parse=function(q,r)r=r or{}local s=r.strict~=nil and r.strict or p.strict;local t="[\009\032]"local u=""local v=1;local w={}local x=w;local function y(z)z=z or 0;return q:sub(v+z,v+z)end;local function A(z)z=z or 1;v=v+z end;local function B()while y():match(t)do A()end end;local function C(g)return g:gsub("^%s*(.-)%s*$","%1")end;local function D(g,E)if g==""then return{}end;local F={}local G=E;if E:match("%%")then G=E:gsub("%%","")end;for H in(g..G):gmatch("(.-)"..E)do table.insert(F,H)end;return F end;local function I(J,K)if not K or K and s then local L=1;local M=0;for N in q:gmatch("(.-)\n")do M=M+N:len()if M>=v then break end;L=L+1 end;error("TOML: "..J.." on line "..L..".",4)end end;local function O()return v<=q:len()end;local function P()local Q=y()local R=y(1)==y(2)and y(1)==y()local g=""A(R and 3 or 1)while O()do if R and y()=="\n"and g==""then A()end;if y()==Q then if R then if y(1)==y(2)and y(1)==Q then A(3)break end else A()break end end;if y()=="\n"and not R then I("Single-line string cannot contain line break")end;if Q=='"'and y()=="\\"then if R and y(1)=="\n"then A(1)while O()do if y()~=" "and y()~="\t"and y()~="\n"then break end;A()end else local S={b="\b",t="\t",n="\n",f="\f",r="\r",['"']='"',["/"]="/",["\\"]="\\"}local function T(y)local U={{0x7ff,192},{0xffff,224},{0x1fffff,240}}if y<128 then return string.char(y)end;local V={}for W,X in pairs(U)do if y<=X[1]then for Y=W+1,2,-1 do local Z=y%64;y=(y-Z)/64;V[Y]=string.char(128+Z)end;V[1]=string.char(X[2]+y)break end end;return table.concat(V)end;if S[y(1)]then g=g..S[y(1)]A(2)elseif y(1)=="u"then A()local _=y(1)..y(2)..y(3)..y(4)A(5)_=tonumber(_,16)g=g..T(_)elseif y(1)=="U"then A()local _=y(1)..y(2)..y(3)..y(4)..y(5)..y(6)..y(7)..y(8)A(9)_=tonumber(_,16)g=g..T(_)else I("Invalid escape")end end else g=g..y()A()end end;return{value=g,type="string"}end;local function a0()local a1=""local a2;local a3=false;while O()do if y():match("[%+%-%.eE0-9]")then if not a2 then if y():lower()=="e"then a2=""else a1=a1 ..y()end elseif y():match("[%+%-0-9]")then a2=a2 ..y()else I("Invalid exponent")end elseif y():match(t)or y()=="#"or y()=="\n"or y()==","or y()=="]"then break elseif y()=="T"or y()=="Z"then a3=true;while O()do if y()==","or y()=="]"or y()=="#"or y()=="\n"or y():match(t)then break end;a1=a1 ..y()A()end else I("Invalid number")end;A()end;if a3 then return{value=a1,type="date"}end;local a4=false;if a1:match("%.")then a4=true end;a2=a2 and tonumber(a2)or 0;a1=tonumber(a1)if not a4 then return{value=math.floor(a1*10^a2),type="int"}end;return{value=a1*10^a2,type="float"}end;local a5,a6;function a5()A()B()local a7;local a8={}while O()do if y()=="]"then break elseif y()=="\n"then A()B()elseif y()=="#"then while O()and y()~="\n"do A()end else local a9=a6()if not a9 then break end;if a7==nil then a7=a9.type elseif a7~=a9.type then I("Mixed types in array",true)end;a8=a8 or{}table.insert(a8,a9.value)if y()==","then A()end;B()end end;A()return{value=a8,type="array"}end;local function aa()local a9;if q:sub(v,v+3)=="true"then A(4)a9={value=true,type="boolean"}elseif q:sub(v,v+4)=="false"then A(5)a9={value=false,type="boolean"}else I("Invalid primitive")end;B()if y()=="#"then while y()~="\n"do A()end end;return a9 end;function a6()if y()=='"'or y()=="'"then return P()elseif y():match("[%+%-0-9]")then return a0()elseif y()=="["then return a5()else return aa()end end;local ab={}while v<=q:len()do if y()=="#"then while y()~="\n"do A()end end;if y()=="\n"or y()=="\r"then end;if y()=="="then A()B()u=C(u)if u==""then I("Empty key name")end;local a9=a6()if a9 then if x[u]then I("Cannot redefine key "..u,true)end;x[u]=a9.value end;u=""B()if y()=="#"then while O()and y()~="\n"do A()end end;if y()~="\n"and v<q:len()then I("Invalid primitive")end elseif y()=="["then u=""A()local ac=false;if y()=="["then ac=true;A()end;while O()do u=u..y()A()if y()=="]"then if ac and y(1)~="]"then I("Mismatching brackets")elseif ac then A()end;break end end;A()u=C(u)x=w;local ad=D(u,"%.")for i,ae in pairs(ad)do if ae==""then I("Empty table name")end;if i==#ad and x[ae]and not ac and#x[ae]>0 then I("Cannot redefine table",true)end;if ab[ae]then if u~=ae and#ad>1 then x=ab[ae]else x[ae]=x[ae]or{}x=x[ae]if ac and i==#ad then table.insert(x,{})x=x[#x]end end else x[ae]=x[ae]or{}x=x[ae]if ac and i==#ad then table.insert(x,{})x=x[#x]end end;ab[u]=x end;u=""end;u=u..y()A()end;return w end;p.encode=function(ae)local q=""local af={}local function ag(ae)for ah,a9 in pairs(ae)do if type(a9)=="boolean"then q=q..ah.." = "..tostring(a9).."\n"elseif type(a9)=="number"then q=q..ah.." = "..tostring(a9).."\n"elseif type(a9)=="string"then local ai='"'a9=a9:gsub("\\","\\\\")if a9:match("^\n(.*)$")then ai=ai:rep(3)a9="\\n"..a9 elseif a9:match("\n")then ai=ai:rep(3)end;a9=a9:gsub("\b","\\b")a9=a9:gsub("\t","\\t")a9=a9:gsub("\f","\\f")a9=a9:gsub("\r","\\r")a9=a9:gsub('"','\\"')a9=a9:gsub("/","\\/")q=q..ah.." = "..ai..a9 ..ai.."\n"elseif type(a9)=="table"then local a8,aj=true,true;local ak={}for al,am in pairs(a9)do if type(al)~="number"then a8=false end;if type(am)~="table"then a9[al]=nil;ak[al]=am;aj=false end end;if a8 then if aj then table.insert(af,ah)for al,am in pairs(a9)do q=q.."[["..table.concat(af,".").."]]\n"for an,ao in pairs(am)do if type(ao)~="table"then am[an]=nil;ak[an]=ao end end;ag(ak)ag(am)end;table.remove(af)else q=q..ah.." = [\n"for al,am in pairs(a9)do q=q..tostring(am)..",\n"end;q=q.."]\n"end else table.insert(af,ah)q=q.."["..table.concat(af,".").."]\n"ag(ak)ag(a9)table.remove(af)end end end end;ag(ae)return q:sub(1,-2)end;return p end)b("metso.lua",function()local p=e("toml.lua")local f=e("connection.lua")local ap=e("promise.lua")local aq={}aq.Promise=ap;aq._backends={mysqloo=e("back_mysqloo.lua"),pg=e("back_pg.lua"),sqlite=e("back_sqlite.lua")}function aq.create(ar)local as=ar.driver or"sqlite"local at=aq._backends[as]assert(not not at,"driver '"..as.."' not implemented.")local au=at.new(ar)return f.new(au)end;function aq._onConfigUpdate()end;aq._config={}function aq._reloadConfig()local av=file.Read("metsodb.toml","GAME")if not av then return end;local Y,aw=pcall(p.parse,av)if not Y then error("Parsing metsodb.toml failed: "..aw)end;aq._config=aw;aq._onConfigUpdate()end;aq._reloadConfig()aq._fallbacks={}function aq.provideFallback(c,ar)assert(type(c)=="string","fallback database name must be a string")assert(type(ar)=="table","fallback opts must be a table")aq._fallbacks[c]=ar end;aq._connCache={}function aq.get(ax)assert(type(ax)=="string","dbname must be a string")local ay=aq._connCache[ax]if ay then return ay end;local az=aq._config[ax]or aq._fallbacks[ax]assert(not not az,"attempted to get inexistent database '"..ax.."'. Make sure it is properly configured in metsodb.toml")local aA=aq.create(az)aq._connCache[ax]=aA;return aA end;return aq end)b("promise.lua",function()local aB={}local aC={}aC.__index=aC;local aD=0;local aE=1;local aF=2;local aG=3;local aH=4;local function aI(aC,aJ)aJ=aJ or aH;for i,aK in ipairs(aC.queue)do if aJ==aG then aK:resolve(aC.value)else aK:reject(aC.value)end end;aC.state=aJ end;local function aL(aK)if type(aK)=='table'then local aM=getmetatable(aK)return aM~=nil and type(aM.__call)=='function'end;return type(aK)=='function'end;local function aN(aC,next,aO,aP,aQ)if type(aC)=='table'and type(aC.value)=='table'and aL(next)then local aR=false;local aS,I=pcall(next,aC.value,function(a9)if aR then return end;aR=true;aC.value=a9;aO()end,function(a9)if aR then return end;aR=true;aC.value=a9;aP()end)if not aS and not aR then aC.value=I;aP()end else aQ()end end;local function aT(aC)local next;if type(aC.value)=='table'then next=aC.value.next end;aN(aC,next,function()aC.state=aE;aT(aC)end,function()aC.state=aF;aT(aC)end,function()local aS;local a9;if aC.state==aE and aL(aC.success)then aS,a9=pcall(aC.success,aC.value)elseif aC.state==aF and aL(aC.failure)then aS,a9=pcall(aC.failure,aC.value)if aS then aC.state=aE end end;if aS~=nil then if aS then aC.value=a9 else aC.value=a9;return aI(aC)end end;if aC.value==aC then aC.value=pcall(error,'resolving promise with itself')return aI(aC)else aN(aC,next,function()aI(aC,aG)end,function(aJ)aI(aC,aJ)end,function()aI(aC,aC.state==aE and aG)end)end end)end;local function aU(aC,aJ,aV)if aC.state==0 then aC.value=aV;aC.state=aJ;aT(aC)end;return aC end;function aC:resolve(aV)return aU(self,aE,aV)end;function aC:reject(aV)return aU(self,aF,aV)end;function aB.new(r)if aL(r)then local aW=aB.new()local aS,I=pcall(r,aW)if not aS then aW:reject(I)end;return aW end;r=r or{}local aW;aW={next=function(self,aO,aP)local next=aB.new({success=aO,failure=aP,extend=r.extend})if aW.state==aG then next:resolve(aW.value)elseif aW.state==aH then next:reject(aW.value)else table.insert(aW.queue,next)end;return next end,state=0,queue={},success=r.success,failure=r.failure}aW=setmetatable(aW,aC)if aL(r.extend)then r.extend(aW)end;return aW end;function aB.all(aX)local aW=aB.new()if#aX==0 then return aW:resolve({})end;local aY="resolve"local aZ=#aX;local a_={}local function b0(i,b1)return function(aV)a_[i]=aV;if not b1 then aY="reject"end;aZ=aZ-1;if aZ==0 then aW[aY](aW,a_)end;return aV end end;for i=1,aZ do aX[i]:next(b0(i,true),b0(i,false))end;return aW end;function aB.map(aX,b2)local aW=aB.new()local a_={}local function b3(i)if i>#aX then aW:resolve(a_)else b2(aX[i]):next(function(l)table.insert(a_,l)b3(i+1)end,function(I)aW:reject(I)end)end end;b3(1)return aW end;function aB.first(aX)local aW=aB.new()for b4,a9 in ipairs(aX)do a9:next(function(l)aW:resolve(l)end,function(I)aW:reject(I)end)end;return aW end;function aC:done(b5)return self:next(b5,function(I)ErrorNoHalt("Promise failed: "..tostring(I))end)end;function aB.resolve(aV)local aW=aB.new()aW:resolve(aV)return aW end;function aB.reject(aV)local aW=aB.new()aW:reject(aV)return aW end;return aB end)b("back_pg.lua",function()pcall(require,"pg")if not pg then return end;local ap=e("promise.lua")local b6={}b6.__index=b6;function b6:query(b7)local aN=ap.new()local b8=self.db:query(b7)b8:on("success",function(b9,ba)self.lastAffectedRows=ba;aN:resolve(b9)end)b8:on("error",function(I)aN:reject(I)end)b8:run()return aN end;function b6:queryLastInsertedId()return self.lastInsertID end;function b6.new(ar)local bb,bc,bd,be,bf=ar.host,ar.username,ar.password,ar.database,ar.port;if not bb then error("Error: host must be specified when using Postgres as the driver")end;if not bc then error("Error: username must be specified when using Postgres as the driver")end;if not bd then error("Error: password must be specified when using Postgres as the driver")end;local bg=pg.new_connection()local bh,I=bg:connect(bb,bc,bd,be,bf)if not bh then error("[Metso] Connection failed: "..tostring(I))end;return setmetatable({db=bg,username=bc,password=bd,database=be},b6)end;return b6 end)b("back_sqlite.lua",function()local ap=e("promise.lua")local bi={}bi.__index=bi;function bi:query(b7)local b9=sql.Query(b7)local aN=ap.new()if b9==false then local I=sql.LastError()aN:reject(I)elseif b9==nil then aN:resolve({})else aN:resolve(b9)end;return aN end;function bi:queryLastInsertedId()return tonumber(sql.Query("SELECT last_insert_rowid() id")[1].id)end;function bi.new(ar)local bc,bd,be=ar.username,ar.password,ar.database;if bc or bd or be then ErrorNoHalt("Warning: username/password/database specified when using sqlite as the driver")end;return setmetatable({},bi)end;return bi end)b("back_mysqloo.lua",function()pcall(require,"mysqloo")if not mysqloo then return end;local ap=e("promise.lua")local bj={}bj.__index=bj;function bj:query(b7)local aN=ap.new()local b8=self.db:query(b7)function b8:onSuccess(b9)self.lastInsertID=b8:lastInsert()self.lastAffectedRows=b8:affectedRows()aN:resolve(b9)end;function b8:onError(I,sql)aN:reject(I)end;b8:start()return aN end;function bj:queryLastInsertedId()return self.lastInsertID end;function bj.new(ar)local bb,bc,bd,be,bf,bk=ar.host,ar.username,ar.password,ar.database,ar.port,ar.socket;if not bb then error("Error: host must be specified when using MysqlOO as the driver")end;if not bc then error("Error: username must be specified when using MysqlOO as the driver")end;if not bd then error("Error: password must be specified when using MysqlOO as the driver")end;local bg=mysqloo.connect(bb,bc,bd,be,bf,bk)local bl,bm;bg.onConnected=function(bg)bl=true;bm=bg end;bg.onConnectionFailed=function(bg,I)bl=false;bm=I end;bg:connect()bg:wait()if not bl then error("[Metso] Connection failed: "..tostring(bm))end;bg:query("SET NAMES utf8mb4")return setmetatable({db=bg,username=bc,password=bd,database=be},bj)end;return bj end)return e("metso.lua")
